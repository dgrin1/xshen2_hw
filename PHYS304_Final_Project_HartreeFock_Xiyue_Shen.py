# -*- coding: utf-8 -*-
"""Hatree_Fock_clean.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JNROBLzLtg6_79toEmodkjAXy3QTS_dn

Computational Physics Final Project: The Hatree-Fock Method

Names:

Xingyun Yang

Xiyue Shen

Adi Advani
"""

import numpy as np
from math import *
from numpy.linalg import matrix_power
import numpy.linalg
import scipy
import matplotlib.pyplot as plt

plt.rcParams['text.usetex'] = True
plt.rcParams['text.latex.preamble'] = r'\usepackage{bm}'
plt.rcParams['pgf.texsystem'] = 'pdflatex'  # or 'latex'

def hmatrold(z1, z2):
  h12 = 4*(z1**3 * z2**3)**0.5 * (z1*z2 - Z*(z1 + z2)) / ((z1 + z2)**3)
  h21 = 4*(z1**3 * z2**3)**0.5 * (z1*z2 - Z*(z1 + z2)) / ((z1 + z2)**3)
  h11 = 4*(z1**3 * z1**3)**0.5 * (z1*z1 - Z*(z1 + z1)) / ((z1 + z1)**3)
  h22 = 4*(z2**3 * z2**3)**0.5 * (z2*z2 - Z*(z2 + z2)) / ((z2 + z2)**3)
  hmat = [[h11, h12], [h21, h22]]
  return hmat

#function for total energy which is to be minimized

# define the two-electron matrix
def twoElec(z1,z2):
  #set up the expectation values of the spatial orbitals
  j1111 = (5/8)*z1
  j2222 = (5/8)*z2
  j1122 = (z1**4*z2 + 4*z1**3*z2**2 + z1*z2**4 + 4*z1**2*z2**3)/((z1 + z2)**4)
  j1212 = 20*z1**3*z2**3/((z1 + z2)**5)
  j1112 = (16*z1**(9/2)*z2**(3/2)/((3*z1 + z2)**4))*((12*z1 + 8*z2)/((z1 + z2)**2) + (9*z1 + z2)/(2*z1**2))
  j1222 = (16*z2**(9/2)*z1**(3/2)/((3*z2 + z1)**4))*((12*z2 + 8*z1)/((z2 + z1)**2) + (9*z2 + z1)/(2*z2**2))

  twoelec = np.array([[[[j1111,j1112],[j1112,j1122]],[[j1112,j1212],[j1212,j1222]]],[[[j1112,j1212],[j1212,j1222]],[[j1122,j1222],[j1222,j2222]]]])

  return twoelec

#Making S matrix and X matrix

def Xmatr(z1, z2):
  s11 = 1
  s22 = 1
  s12 = (8 * z1**(1.5) * z2**(1.5))/ ((z1 + z2)**3)
  smatr = np.zeros((2,2))

  #S matrix
  smatr = np.array([[s11, s12], [s12, s22]])

  # X matrix
  return scipy.linalg.fractional_matrix_power(smatr, -0.5)

# define function for Energy while varing zetas
def energy(zeta1, zeta2):
  # iterate for 10 times
  count = 0

  #set initial F matrix and coefficients
  F_matrix=np.zeros((2,2))
  c=np.zeros((2,2))

  while count < 10:
    count += 1

    #update F matrix
    for r in range(2):
      for s in range(2):
        F_matrix[r][s] = hmatrold(zeta1, zeta2)[r][s]
        for i in range(2):
          for j in range(2):
            F_matrix[r][s] += c[0][i]*c[0][j]*twoElec(zeta1,zeta2)[r][s][i][j]

    Xnew = np.conjugate(np.transpose(Xmatr(zeta1, zeta2)))
    Fnew = np.matmul(np.matmul(Xmatr(zeta1, zeta2), F_matrix) , Xnew)
    x,c = np.linalg.eigh(Fnew)

    #update coefficients
    for k in range(2):
      c[k] = np.matmul(Xmatr(zeta1, zeta2), c[k])

  # summing over the expectation values of single electron operators
  h_sum = 0
  for r in range(2):
    for s in range(2):
      h_sum += c[0][r]*hmatrold(zeta1, zeta2)[r][s]*c[0][s]

  # summing over the expectation values of the spatial orbitals
  psi_sum = 0
  for r in range(2):
      for s in range(2):
        for i in range(2):
          for j in range(2):
            psi_sum += c[0][r]*c[0][s]*c[0][i]*c[0][j]*twoElec(zeta1,zeta2)[r][s][i][j]

  # computing energy
  E = 2*h_sum + psi_sum


  return E

#generate a grid of possible zeta1 and zeta2's
zeta1s=np.linspace(4.4,4.8,50)
zeta2s=np.linspace(2.3,2.7,50)

#set Z
Z = 3

#calculate correponding energy gird
E=np.zeros((len(zeta1s),len(zeta2s)))
for i in range(len(zeta1s)):
  for j in range(len(zeta2s)):
    energy_point=energy(zeta1s[i],zeta2s[j])
    E[i][j] = energy_point

#create meshgrid for 3d plot
Z1, Z2 = np.meshgrid(zeta1s, zeta2s)

# check plot to see a global minimum
fig = plt.figure()
ax = plt.axes(projection = '3d')
ax.plot_surface(Z1, Z2, E, cmap='viridis')
ax.set_xlabel(r'$\zeta_1$')
ax.set_ylabel(r'$\zeta_2$')
ax.set_zlabel(r'E')
ax.set_title(r'$\zeta$ vs E')
plt.savefig('3d.png')
plt.show()

# get the zeta1 and zeta2 combo that minimizes E
zeta1_idx, zeta2_idx = np.where(E == np.min(E))
zeta1min = zeta1s[zeta1_idx[0]]
zeta2min = zeta2s[zeta2_idx[0]]
print('minimized zeta1 and zeta2: ', zeta1min, zeta2min)

#compare minimized zeta1 and zeta2 combo with a polynomial fit method

# polynomial fit
polynomial_coeff = np.polyfit(zeta1s, E[:,zeta2_idx[0]], 3)
polynomial = np.poly1d(polynomial_coeff)
print('fitted polynomial:\n', polynomial)

#calculate derivative
derivative = np.polyder(polynomial)
print('derivative of polynomial:\n', derivative)

#root of derivative to find extrema
allroot = np.roots(derivative.coefficients)
root = []
for i in allroot:
  if zeta1s[0] <= i <= zeta1s[-1]:
    root.append(i)

#plot comparing two methods for minized zeta1
plt.plot(zeta1s, E[:,zeta2_idx[0]], label='data')
plt.plot(zeta1s, polynomial(zeta1s), label='polynomial fit')
plt.plot(constrained_layout=True)
plt.axvline(x=zeta1min, color = 'g', linestyle='-.', label='min, HF array')
plt.axvline(x=root[0], color = 'r', linestyle='--', label='min, polyfit')
plt.xlabel(r'$\zeta_1$')
plt.ylabel(r'E')
plt.title(r'$\zeta_1$ vs E')
plt.legend()
plt.savefig('zeta1.png')
plt.show()

#repeat for zeta 2
polynomial_coeff = np.polyfit(zeta2s, E[zeta1_idx[0]], 3)
polynomial = np.poly1d(polynomial_coeff)
print('fitted polynomial:\n', polynomial)
derivative = np.polyder(polynomial)
print('derivative of polynomial:\n', derivative)

#root of derivative
allroot = np.roots(derivative.coefficients)
root = []
for i in allroot:
  if zeta2s[0] <= i <= zeta2s[-1]:
    root.append(i)

plt.plot(zeta2s, E[zeta1_idx[0]], label='data')
plt.plot(zeta2s, polynomial(zeta2s), label='polynomial fit')
plt.axvline(x=zeta2min, color = 'g', linestyle='-.', label='min, HF array')
plt.axvline(x=root[0], color = 'r', linestyle='--', label='min, polyfit')
plt.xlabel(r'$\zeta_2$')
plt.ylabel(r'E')
plt.title(r'$\zeta_2$ vs E')
plt.legend()
plt.savefig('zeta2.png')
plt.show()